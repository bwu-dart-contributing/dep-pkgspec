# Package-Spec

## Contact information

Name: Lasse R.H. Nielsen  
E-mail: lrn@google.com  
[DEP Proposal Location][]  
Further stakeholders:  
- Johnni Winther - johnniwinther@google.com
- Ivan Posva - iposva@google.com

## Summary

Specify Dart tools' "package:" URI resolution in a separate package-specification file.

## Motivation

Dart tools currently resolve package-URIs using the "--package-root" command line parameter to specify a directory, and resolving the path-part of a package URI against this directory (defaulting to the "packages" sub-directory of the current working directory if no "--package-root" parameter is given).

This approach has some shortcomings.

First and foremost, the packages must all be represented in a centralized location of a single file system.
This is currently accomplished by creating a "packages" directory and creating a symbolic link to the "pub" cache location for each package.

Symbolic links are not working well on Windows systems, and they do not interact well with most version control systems.

Copying the contents instead of using symbolic links does not scale, with developing mutually dependent packages as a problematic use case.

Also, symbolic links can't always span multiple file systems, making it impossible to have some imports from local disk and other imports from, e.g., a HTTP server.


Using a package specification file that associates a base directory to each package name, it becomes possible to reference packages from different sources directly.
It avoids creating extra directories with symbolic links, and instead puts the same information into a single text file. Text files work flawlessly with version control systems and they can be edited with a simple text editor if needed.

## Examples

An example "pkgspec.txt" file could be:

    # auto-generated 2015-12-24 from somewhere/projectname/pubspec.yaml
    unittest=/home/somebody/.pub/cache/unittest-0.9.9/lib/
    async=/home/somebody/.pub/cache/async-1.1.0/lib/
    quiver=/home/somebody/.pub/cache/quiver-1.2.1/lib/
    # end auto-generated
    homebrew=../../libs/homebrew/lib/
    rawangular=https://raw.githubusercontent.com/angular/angular.dart/master/lib/

This package specification will allow a program run using it to import `package:unittest/unittest.dart` and receive the file `/home/somebody/.pub/cache/unittest-0.9.9/lib/unittest.dart`.

At the same time, other libraries can be fetched from the net every time they are needed, or from another project that is still in development.

I envision the comment-delimited lines have been automatically generated by the "pub" tool, while keeping the manually added lines unchanged.

## Proposal

The solution proposed here is:

- Dart tools can load their "package"-URI resolution from a single file.
- The proposed default name is "pkgspec.txt".
- The file uses a simple single-line key/value format, similar to the Java `Properties` file format or the Windows `ini` file format. This format is deliberately kept simple and only does what is needed, in comformance with the KISS and YAGNI principples.
- Tools that now support a "--package-root" parameter must also support a "--package-spec" parameter which takes a (non-package:) URI as argument.

The file itself has the following format:
- It is UTF-8 encoded (but non-ASCII characters may only occur in comments).
- Lines are separated by CR (U+000A) or LF (U+000D) characters.
- Empty lines are ignored (allowing CR+LF as line separator to work automaticaly).
- Lines starting with a `#` character are comments and are ignored.
- All other lines must contain a `=` character.
- The characters before the first `=` character is a package name. A package name is a URI path segment that is not `.` or `..`. The package name should be case and escape normalized except that any `=` must be percent escaped as `%3D`.
- The characters after the first `=` character must be a URI reference. It should end in a `/`.
- If the same package name occurs twice in the file (two entries that are equal after normalization), it is an error. The tool may fail, or it may give a warning and continue running using one of the entries. The error should never be accepted silently.

Most likely all package names will be valid Dart identifiers, so there will be no escapes. If the package name contains escapes, the system will normalize it so that it can be compared to the names used in "package:packageName/..." URIs.

The URI reference be a relative URI, in which case it is resolved against the location of the package specification file itself. That is, a line like:

    homebrew=../../homebrew/lib

will be resolved relative to the location of the package file. This should specifies a directory, so if the path does not end in a slash ('/'), then one will be added.

After loading and resolving the package-name/package-location pairs from the package specifcation, the tool will resolve "package" URIs using this information.

For example, the import `import 'package:unittest/unittest.dart';` is resolved by first case and path normalizing the URI (to avoid spurious `..` path segments and to get then package name on a canonical form), then splitting it into the package name, `unittest` and the remainder of the path, `unittest.dart`.
If the `unittest` package was specified as:

    unittest=../../packages/unittest-0.9.9/lib

in the specification file `/home/somebody/dart/project/smarty/pkgspec.txt`, then the base path of the package `unittest` is `/home/somebody/dart/packages/unittest-0.9.9/lib/`. The remaining path "unittest.dart" is resolved against this, getting `/home/somebody/dart/packages/unittest-0.9.9/lib/unittest.dart`.

As another example, the import `import 'package:unittest/../../bar/something.dart';` is first normalized to import `'package:bar/something.dart'` before it's resolved. This avoids clever URIs from escaping from the specified package locations and reading arbitrary files on the same system.

If a tool gets neither a "--package-spec" or a "--package-root" command line parameter, it may look for a "pkgspec.txt" file next to the program entry point (which can then not be given using a package: URI). For example running an application like:

    dart http://example.com/smarty/main.dart

will cause the `dart` stand-alone VM to check for the existence of `http://example.com/smarty/pkgspec.txt`, and if that URI returns a file, use the content for resolving package URIs in the application.

If the package-spec file isn't found, the tools should fall back on assuming a "packages" directory next to the entry-point, as if that had been specified using "--package-root".


As part of the implementation of this proposal, the "pub" tool should be changed to allow writing a `pkgspec.txt` file where it currently creates a "package" directory in a package's root directory.

Tools that need to support the "--package-spec" parameter includes the standalone VM, dart2js, and dart-analyzer.

## Alternatives

The simplest alternative is to keep using just the "--package-root" parameter.
The shortcomings are not crippling in most cases, but it has some problems that are not easily solved.

Alternative implementations of the same concept could be:

- Using a more complex format for the `pkgspec.txt` file, perhaps `pkgspec.yaml` or `pkgspec.json`. This adds extra overhead and complexity, changing it from a line-based format to a structured format. This makes tools more complex, and since the file must be read on start-up, more complexity may increase the delay before code can start running. On the other hand, if we ever need to add more runtime project data, we would already have a file that we can just add more sections to. Overall, I don't think the extra complexity is warranted until we have a specific need, which may never happen.
On the other hand, a structured format can be extended without affecting existing tools, if they only access a specific part of the structured data.

- Allowing more than one specification file on the command line, and perhaps allow imports in specification files. This would allow reuse of existing files, and patching together a configuration from partial configurations. Again this will increase start-up latency, and will probably require a more complex format.

- Simplifying the format by dropping comments. Comments are very useful for both manually written files and for adding extra information.

- Allowing extra white-space in the format at the start and end of a line and around the `=`. This allows, for example, aligning entries, but requires defining "whitespace" and (very) slightly increases the complexity of the parser. It's not necessary, but might be convenient. Just accepting space and tab is likely sufficient for most users, but it's also annoying to have other white-space characters not allowed if they are not visually distinguishable from allowed spaces.

- A tool only looks for the `pkgspec.txt` file next to the entry point. It may be useful if the tool checks the parent directory as well, recursively, so that there is no need for extra pkgspec-files when running files in a sub-directory. This mainly makes sense for local files, so it could be done only if the entry-point is a file: URI. This still takes extra time in the case where there is no file in any higher-level directory, and the search reaches the root directory. Some file systems may have networked directories in the parent path, even if the current directory is on local disk, making the extra lookup potentially more expensive. If it's possible to do without this feature, I'd try without it at first. It can be added later.

- Add sections like in Windows ini-files. A section is begun by a line like `[section name]` and reaches until the next section or the end of the file. Sections have no influence on resolution, but can allow tools that create or manipulate the pkgspec file to tag specific entries in the file. The same behavior can be achieved using recognizable comments (like in the first example above), but if the feature is useful, it is safer to have it supported explicitly instead of hacking it up using meaningful comments. Parsers that are uninterested in sections can treat a line starting with `[` as a comment. A `[` character is not valid in a path segment, so using it for comments is not ambiguous.

- Allow the same package name to occur more than once, associating it to more than one target location. Resolving a file in that package then checks each possible target location in order until it finds one that holds the requested file. The use of this feature is highly speculative, but could allow some parts of a package to reside in a different location than the rest, without having to copy the files to a common location.

## Implications and limitations

Adding the package-spec as the way to configure package-URI resolution will affect start-up time for the VM. The VM will then need to load and parse the file before it can import any library through a package-URI, where it can now just check for the package's directory in the package-root when the package is first used. Unused packages cost to load the specification for, even if they are never used.
The format was picked to be quick for the VM to parse.

The `Isolate.spawnUri` function has a `packageRoot` parameter. It should probably be extended with a `packageSpec` parameter of type `Map<String,Uri>`. If both parameters are supplied in a call, the `spawnUri` function should throw.

There should be a package for reading and writing `pkgspec.txt` files, converting to and from `Map<String, Uri>`.

The "per package name" configuration enforces that package names are special, they are not just the first segment of path of the `package:` URI. Nothing currently prevents placing a file *in* the "package" directory, say "trick.dart" and then importing "package:trick.dart". With the package-spec file, that is no longer possible, because "trick.dart" would be seen as a package name and the file path is missing, so it would not find any file.

Making package names special may be a good thing. It allows for a later change where package URIs are scheme normalized before using, so that "package:unittest" will be normalized to "package:unittest/unittest.dart", effectively allowing a shorthand for the default-named library of a package. With the current resolution, that is not possible - "package:unittest" may be referring to the "unittest" file in the package root directory.


## Deliverables

### Language specification changes

The Dart specification currently says that:
> A URI of the form package:s is interpreted as a URI of the form packages/s
> relative to an implementation specified location.

It should be changed to something like:
> A path-normalized URI of the form package:s/p is interpreted as a
> relative URI of the form p resolved relative to an implementation specified
> location depending on s.

### A working implementation

An [initial implementation] of reading and writing package specification files has been created.
This can be used as a starting point for Dart based tools to read the package specification.

### Tests

No tests have been written.

## Patents rights

TC52, the Ecma technical committee working on evolving the open [Dart standard][], operates under a royalty-free patent policy, [RFPP][] (PDF). This means if the proposal graduates to being sent to TC52, you will have to sign the Ecma TC52 [external contributer form]() and submit it to Ecma.

[DEP Proposal Location]: https://github.com/lrhn/dep-pkgspec/
[initial implementation]: https://codereview.chromium.org/772463002/
[dart standard]: http://www.ecma-international.org/publications/standards/Ecma-408.htm
[rfpp]: http://www.ecma-international.org/memento/TC52%20policy/Ecma%20Experimental%20TC52%20Royalty-Free%20Patent%20Policy.pdf
[form]: http://www.ecma-international.org/memento/TC52%20policy/Contribution%20form%20to%20TC52%20Royalty%20Free%20Task%20Group%20as%20a%20non-member.pdf
